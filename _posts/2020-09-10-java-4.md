---
layout: post
title:  "java基础面试知识点总结-4"
categories: [java,jvm]
tags:  [Java,IT]
excerpt: 总结记录的一些有关java基础知识的面试题

---

## JDK 1.8 G1垃圾收集算法的改进？

G1（Garbage First）提供的一个工作在新生代基于“复制算法”和老年代基于“标记-整理”算法实现的收集器，在收集结束后可以避免内存碎片问题。

1. 并行与并发：充分利用多CPU来缩短Stop The World的停顿时间；
2. 分代收集：不需要其他收集配合就可以管理整个Java堆，采用不同的方式处理新建的对象、已经存活一段时间和经历过多次GC的对象获取更好的收集效果;
3. 空间整合：与CMS的”标记-清除”算法不同，G1在运行期间不会产生内存空间碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于无法申请到足够大的连续内存而提前触发一次Full GC;
4. 停顿预测：G1中可以建立可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

 

1、优化G1性能调优的参数项。开发人员仅仅需要声明以下参数即可：

-XX:+UseG1GC –Xmx16g -XX:MaxGCPauseMillis=200

​    其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx16g 设计堆内存的最大内存为16G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。

 

2、G1将Java整个堆的内存布局划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离，都是一部分Region（不需要连续）的集合。取消了新生代，老年代的物理空间划分。这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。

 

3、移除了永久代（Permanent Generation）使用本地化的内存存放类的元数据，这个空间叫做元空间（Metaspace）。

 

## Java8新特性如何使用，函数式编程为什么要添加进来

​    **方法引用**(Method Reference)，在Java8中用**“****::****”**双冒号操作符来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。我们可以直接通过方法引用来**简写**lambda表达式中已经存在的方法。方法引用分类：

| **类型**     | **语法**           | **对应的****Lambda****表达式**       |
| ------------ | ------------------ | ------------------------------------ |
| 静态方法引用 | 类名::staticMethod | (args) -> 类名.staticMethod(args)    |
| 实例方法引用 | inst::instMethod   | (args) -> inst.instMethod(args)      |
| 对象方法引用 | 类名::instMethod   | (inst,args) -> 类名.instMethod(args) |
| 构建方法引用 | 类名::new          | (args) -> new 类名(args)             |

​    面向对象编程是对数据进行抽象，而[函数式编程](https://www.baidu.com/s?wd=函数式编程&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)是对（某一类共有的）行为进行抽象。Java8新引入函数式编程方式，函数式编程语法能够精简代码，大大的提高了编码效率。在面对大型数据集合时，为了能够更加高效的开发，编写的代码更加易于维护，更加容易运行在多核CPU上，Java在语言层面增加了Lambda表达式。Lambda表达式即匿名函数，它是一段没有函数名的函数体，可以作为参数直接传递给相关调用者。而函数式接口是Java支持函数式编程的基础。

​    **函数式接口**(Functional Interface)**：**是Java8中新定义了一种接口类型，它与其他接口的区别：

1. 函数式接口中只能有一个抽象方法（但是可以有多个非抽象方法，还不包括与Object的方法重名的方法，在Java9允许接口中定义私有实现方法，封装给Java8允许接口默认方法内部调用）；

2. 可以有从Object继承过来的抽象方法，因为所有类的最终父类都是Object；

3. 接口中唯一抽象方法的命名并不重要，因为函数式接口就是对某一行为进行抽象，主要目的就是可以被隐式（匿名）转换为Lambda表达式。

​    一般通过@FunctionalInterface这个注解来表明某个接口是一个函数式接口,虽然这个注解的使用不是强制性的，但是使用它的好处是让此接口的目的更加明确，同时编译器也会对代码进行检查，来确保被该注解标注的接口的使用没有语法错误。

​    此前就有Comparator<T>和Runnable函数式接口，Java8在java.util.function包下又内置了四种核心函数式接口：

| **函数式接口** | **参数类型** | **返回类型** | **用途**                                                     |
| -------------- | ------------ | ------------ | ------------------------------------------------------------ |
| Consumer       | T            | 无           | 消费型接口，对类型T参数操作，无返回结果，包含方法 void accept(T t) |
| Supplier       | 无           | T            | 供给型接口，返回T类型参数，方法时 T get()                    |
| Function       | T            | R            | 函数型接口，对类型T参数操作，返回R类型参数，包含方法 R apply（T t） |
| Predicate      | T            | boolean      | 断言型接口，对类型T进行条件筛选操作，返回boolean，包含方法 boolean test（T t） |

 

## Java9比Java8改进了什么；

**String****底层存储结构更换：**Java8之前 String的底层结构类型都是 char[] ,但是Java9 就替换成 byte[] 这样来讲，更节省了空间和提高了性能。

**接口规范改进：**可私有接口的方法，默认和静态方法更好的共享接口的私有方法。若私有方法为静态该方法属于这个接口，不为静态则只能被该接口的实例调用。

**提供创建不可变集合的静态工厂方法**

List、Set、Map 接口中，提供新的静态工厂方法直接创建不可变的集合实例。

作用：创建不可变集合更方便，一行代码就搞定，节省了开销。

**私有接口方法**

在接口中也允许编写 private 修饰的私有方法了。

作用：增强了接口的功能，提高了可扩展性。

