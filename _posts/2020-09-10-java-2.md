---
layout: post
title:  "java基础面试知识点总结-2"
categories: [java,jvm]
tags:  [Java,IT]
excerpt: 总结记录的一些有关java基础知识的面试题

---

## String与StringBuffer的区别

**String****：**

1、String是final类，即不能被继承。

2、是对象（引用）类型不是原始类型，String对象为不可变对象，一旦被创建，就不能修改它的值。

3、对已创建好的String对象进行修改操作，每次都必须重新创建新的对象来保存新的值。

**StringBuffer****：**

1、是一个可变字符串类，底层为可变char[]默认capacity=16，只能通过new关键字调构造函数来创建对象；操作方法都是synchronized同步的，线程安全。

2、当对StringBuffer实例化对象进行修改时，不会像String那样重新建立对象，通过它的append方法向其赋值，只对这一个对象操作。

3、字符串连接操作中StringBuffer的效率要明显比String高。

## GC算法，垃圾回收算法的优缺点

### 1、引用计数法（引用和去引用伴随加法和减法，影响性能；很难处理循环引用。已被淘汰 –> 根搜索算法）

![image](http://image.itstabber.com/2020-09-09/clip_image012.png)

### **2、根搜索算法：**

处理方式就是**可达性分析算法**，设立若干种根对象，从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“**引用链**”，当任何一个根对象到某一个对象没有任何引用链相连（就是从GC Roots到这个对象不可达）时，则认为此对象不可用，是可以被回收的。

可以当做GC roots根对象有以下几种：

（1）栈（栈帧中的本地变量表）中引用的对象。

（2）方法区中的静态成员。

（3）方法区中（声明为final）的常量引用的对象（全局变量的值）

（4）本地方法栈中JNI（一般说的Native方法）引用的对象。

### **3、** **标记清除法**（Mark-Sweep）

![image](http://image.itstabber.com/2020-09-09/clip_image013.jpg)

### **4、** **标记整理法**（Mark-Compact / Tidy）

![img](http://image.itstabber.com/2020-09-09/clip_image014.png)

### **5、** **标记清除压缩法**（Mark-Sweep-Compact）

![img](http://image.itstabber.com/2020-09-09/clip_image015.png) 

### **6、** **复制算法**（Copying）

![img](http://image.itstabber.com/2020-09-09/clip_image016.png)

在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有**三种**，分别是上面提到的：标记清除算法、复制算法、标记整理算法。这三种算法都扩充了根搜索算法。

**它们的区别如下：**（>表示前者要优于后者，=表示两者效果一样）

**（1）效率**（仅对比**时间复杂度**）：复制算法**>**标记整理算法**>**标记清除算法。

**（2）内存整齐度**：复制算法**=**标记整理算法**>**标记清除算法。

**（3）内存利用率**：标记整理算法**=**标记清除算法**>**复制算法。

注1：可以看到标记清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的。

注2：时间与空间不可兼得。

### **7、****分代收集算法**（Generational Collection）

根据对象的存活周期的不同将内存划分为：新生代（短命对象）和老年代（长命对象）。

**少量对象存活，适合复制算法**：在**新生代**中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。

**大量对象存活，适合用标记清理 / 标记整理**：在**老年代**中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。

**注：**老年代的对象中，有一小部分是因为在新生代回收时，老年代**做担保**，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代。

## 垃圾收集器

### **1、** **Serial****收集器**

串行回收器（单线程收集器）只使用一个 CPU 和一个收集线程，垃圾回收时暂停其他所有的工作线程，直到收集结束。每次回收时只有一个工作线程，对于并发能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的表现，对于运行在 Client 模式下的虚拟机是一个好选择。串行回收器可以在新生代和老年代使用，新生代采用复制算法，老年代采用标记整理算法。根据作用的堆空间不同，分为新生代串行回收器和老年代串行回收器。

Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stopthe world(服务暂停)。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器。

参数控制：-XX:+UseSerialGC 使用串行收集器

### **2****、ParNew收集器**

ParNew收集器是一个工作在新生代的垃圾收集器，它只是简单的将串行收集器多线程化，它的回收策略和算法和串行回收器一样。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩。能与 CMS 收集器 [配置 ](http://www.liuhaihua.cn/archives/tag/配置)工作，所以是许多运行在 Server 模式下的首选新生代收集器。

在垃圾收集器的上下文中，先明确两个概念：

**并行（Parallel）：**多条垃圾线程并行工作，用户线程仍然处于等待状态

**并发（Concurrent）：**用户线程和垃圾回收线程同时执行（不一定并行，可能会交替执行）

并行收集器关注吞吐量优先，并发收集器关注响应时间优先。

参数控制：-XX:+UseParNewGC 使用ParNew收集器   -XX:ParallelGCThreads 限制线程数量

### **3****、Parallel Scavenge收集器**（并行清除）

Parallel是采用复制算法的多线程新生代垃圾回收器，Parallel收集器更关注系统的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；

而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩

参数控制：-XX:MaxGCPauseMillis 设置最大垃圾收集停顿时间   -XX:GCTimeRatio 设置吞吐量的大小(默认是99)  -XX:+UseAdaptiveSeizPolicy 打开自适应模式

### **4****、Parallel Old收集器**

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法，也是比较关注吞吐量。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

参数控制：-XX:+UseParallelOldGC 使用ParallelOld收集器 -XX:ParallelGCThreads 限制线程数量

### **5****、CMS收集器**

**CMS(Concurrent Mark Sweep)****并发****标记请除**，它使用的是标记请除法，工作在老年代，主要关注系统的停顿时间。

CMS并不是独占的回收器，也就是说，CMS回收的过程中应用程序仍然在不停的工作，又会有新的垃圾不断的产生，所以在使用CMS的过程中应该确保应用程序的内存足够可用，CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阀值(默认为68)的时候开始回收，也就是说当老年代的空间使用率达到68%的时候回执行CMS。如果内存使用率增长很快，在CMS执行过程中，已经出现了内存不足的情况，此时，CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这会导致应用程序中断，直到垃圾回收完成后才会正常工作，这个过程GC的停顿时间可能较长，所以阀值的设置要根据实际情况设置。

标记清除法的缺点是内存碎片问题，CMS提供提供了一些优化设置，可以设置完成CMS之后进行一次碎片整理，也可以设置进行多少次CMS回收后进行碎片整理

参数控制：-XX:CMSInitatingPermOccupancyFraction 设置阀值 -XX:+UserConcMarkSweepGC 使用cms垃圾清理器  -XX:ConcGCThreads 限制线程数量 -XX:+UseCMSCompactAtFullCollection 设置完成CMS之后进行一次碎片整理 -XX:CMSFullGCsBeforeCompaction 设置进行多少次CMS回收后进行碎片整理

### **6****、G1收集器**

**G1(Garbage First)****垃圾收集器**是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。

**并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

**分代收集**：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

**空间整合**：与CMS的“标记-清理”算法不同，G1从整体看来是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上看是基于“复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

**可预测的停顿**：这是G1相对于CMS的另外一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器特征了。

参数控制：-XX:+UseG1GC 使用G1垃圾收集器  -XX:ParallelGCThreads 限制线程数量  -XX:MaxGCPauseMillis 指定最大停顿时间

## GC Root什么算法知道对象要被回收

​    GC Root即根搜索算法、可达性分析算法、分析对象的引用链、解决循环引用的问题。

可达性分析算法的思想：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。

当一个对象不可达GC Roots时，这个对象并不会马上被回收，而是处于一个死缓的阶段，若要被真正的回收需要经历两次标记。如果对象在可达性分析中没有与GC Roots的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已经被虚拟机调用过，那么就认为是没必要的。

如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的队列中，虚拟机会触发一个finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这还是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除“即将回收”集合，等待回收。

## Java内存调优怎么做的

### **监控GC状态 》 分析堆Dump文件（工具） 》 分析JVM内存泄露（原因） 》 调优JVM参数。**

1、 查看应用程序日志，使用JVM提供的内存查看工具（如JConsole和Java VisualVM），分析当前堆内存快照dump文件和GC日志。

2、 分析当前JVM参数设置，根据实际的堆内存各区域划分和GC执行频次和时间分析问题。

3、 找准问题原因和问题代码，结合业务和技术，做出问题代码的改进和优化处理。

4、 或是调整GC收集器类型和策略参数，合理控制堆内存各区域的分配大小比例。

### **堆内存各区域比例不良设置会导致什么后果：**

1）新生代设置过小

一是新生代GC次数非常频繁，增大系统消耗；

二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC

2）新生代设置过大（一般说来新生代占整个堆1/3比较合适）

一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；

二是新生代GC耗时大幅度增加

3）Survivor设置过小

导致对象从Eden直接到达旧生代，降低了在新生代的存活时间

4）Survivor设置过大

导致Eden过小，增加了GC频率

另外，通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收

### **JVM****提供两种较为简单的GC策略的设置方式：**

1）吞吐量throughput优先，这个值可由-XX:GCTimeRatio=n来设置。

2）暂停pause时间优先，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置。

### **Java****自带分析工具：**jstack(查看线程)、jmap(查看内存)和jstat(性能分析)命令

1、通过 jstat -gc pid interval 监测程序的实时运行情况，包括堆内存信息（每一个分区的内存使用率变化情况）以及垃圾回收信息。

2、通过jcmd pid VM.flags 就可以查看到jvm相关的设置参数

3、通过jstack pid命令查看分析线程堆栈信息，通常会结合 top -Hp pid 或 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常

4、通过jmap -heap 进程id查看堆内存初始化配置信息以及堆内存的使用情况，其中就包括垃圾收集器的设置类型，输出堆内存中的对象信息，包括产生了哪些对象，对象数量多少等。

5、通过 jmap -histo[:live] 进程id | more 查看堆内存中的对象数目、大小统计直方图，如果带上 live 则只统计活对象。

6、还可以通过jmap –dump:format=b,file=/tmp/heap.hprof 进程id命令把堆内存的使用情况 dump 到文件中（一般dump文件都比较大）

7、查看 & 分析 GC 日志

首先，我们需要通过 JVM 参数预先设置 GC 日志，通常有以下几种 JVM 参数设置：

-XX:+PrintGC 输出GC日志

-XX:+PrintGCDetails 输出GC的详细日志

-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）

-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）

-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息

-Xloggc:../logs/gc.log 日志文件的输出路径

 eg：-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heapTest.log

如果GC日志非常大，可以用GCViewer工具打开日志文件，图形化界面查看整体的 GC 性能。也可以用GCeasy工具，并且还可以将日志文件压缩之后，上传到 GCeasy 官网即可看到非常清楚的 GC 日志分析结果。

8、各种JVM参数调优（比例、大小、年龄、阀值、开启与并闭、）

9、Linux系统工具

（1）top命令：实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息

（2）top Hp pid命令：查看具体线程使用系统资源情况

（3）vmstat 命令：是一款指定采样周期和次数的功能性监测工具，我们可以看到，它不仅可以统计内存的使用情况，还可以观测到 CPU 的使用率、swap 的使用情况。但 vmstat 一般很少用来查看内存的使用情况，而是经常被用来观察进程的上下文切换。

（4）pidstat命令：是 Sysstat 中的一个组件；可以通过yum install sysstat 安装该监控组件。pidstat 命令则是深入到线程级别的监测工具。

## 有台节点内存溢出，怎么定位问题。整个过程

**引起内存溢出的原因有很多种，列举一下常见的有以下几种：**

1、内存中加载的数据量过于庞大，如一次从数据库查询出过多数据到内存中；

2、集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；

3、代码中存在死循环或循环内部产生过多的重复的大型对象实体；

4、使用了第三方软件中的BUG；

5、启动参数内存值设定的过小；

## **使用内存查看工具动态查看内存使用情况：**

**1****、检查GC日志**：确定内存溢出报错是哪个内存划分区域，不同区域的溢出处理不同；主要有永久代（元空间）、堆、本地方法栈三个区域会出现溢出。

**2.1****、永久代溢出：**java.lang.OutOfMemoryError: PermGen space

​    其全称是Permanent Generation space,是指内存的永久保存区域, 这块内存主要是存放Class和Meta信息的,Class在被Load时就会被放到PermGen space中, GC(Garbage Collection)不会在主程序运行期对 PermGen space进行清理。如果应用中加载的class与jar文件大小超过-XX:MaxPermSize就有可能会产生PermGen space OOMError。通常-XX:MaxPermSize设为-Xmx的1/8。

**2.2****、方法区溢出：**Exception in thread "main" java.lang.OutOfMemoryError: Metaspace

​    在HotSpot中，从Jdk8开始，方法区的实现由永久代变更为元空间（MetaSpace），元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。随着类的加载，元空间使用量逐渐增加，可视情况设置将JVM参数：-XX:MetaspaceSize、-XX:MaxMetaspaceSize调整大小。

**3****、堆内存溢出：**java.lang.OutOfMemoryError: Java heap space

​    通过JVM自带的分析工具，找到产生heap space内存溢出时，堆内存中是哪个类的对象存活数量过多而导致溢出的问题根源。可以通过jdk/bin/jconsole.exe和jdk/bin/jvisualvm.exe两个可视工具来定位。生产环境还可以在启动JVM时加上参数指定Dump文件路径，或通过jmap来转储堆内存dump文件进行离线分析。

**4****、方法栈溢出：**Exception in thread "main" java.lang.StackOverflowError

## **栈溢出的原因**

·    是否有递归调用

·    是否有大量循环或死循环

·    全局变量（常量）是否过多

·    数组、List、map等集合数据是否过大

## **内存溢出的解决方案：**

1、检查对数据库查询中，是否有一次获得全部数据的查询。如果一次取十万条记录到内存，就可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

2、检查代码中是否有死循环或递归调用，优化代码逻辑。

3、检查是否有大循环重复产生新对象实体，优化代码逻辑。

4、检查List、Map等集合对象是否有使用完后，未清除，始终存有对对象的引用而不能被GC回收。

5、调优JVM启动参数

6、强化并建立代码规范，定期执行迭代版本代码的Review

## 常见的JVM调优方法有哪些？可以具体到调整哪个参数，调成什么值？

主要针对年轻代、年老代、持久代；堆栈等大小进行设置；内存溢出分2类：

\1. 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace

\2. 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace

**1****、新生代和老年代溢出：**java.lang.OutOfMemoryError:java heep space;当98%时间用于垃圾回收时,且可用的Heap size 不足2%的时候将抛出此异常信息；

**解决方法：****手动设置JVM Heap（堆）的大小**

**2****、持久代溢出：**java.lang.OutOfMemoryError: PermGen space

**解决方法：** **通过-XX:PermSize和-XX:MaxPermSize设置永久代大小即可。**

**3****、栈溢出：java.lang.StackOverFlowError:Thread stack space**

栈区远远小于堆区,栈区需要的内存大小1-2m左右；出现栈溢出，即说明单线程运行程序需要的内存太大；

**解决方法：****1****：修改程序。2：通过 -Xss: 来设置每个线程的Stack大小即可。**

 

## JVM调优参数参考

1、JVM堆大小设置，通过-Xms -Xmx限定其最小、最大值。为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值。

2、年轻代和年老代默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把它们设置为同样大小。

3、年轻代和年老代设置多大才算合理

（1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC

（2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率

如何选择应该依赖应用程序对象生命周期的分布情况： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。

在抉择时应该根据以下两点：

（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM默认比例1：2也是这个道理。

（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。

4、在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。

5、线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

 

**JVM****服务参数调优实战——大型网站服务器案例**

承受海量访问的动态Web应用

服务器配置：8 CPU, 8G MEM, JDK 1.6.X

参数方案：

-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC

调优说明：

- -Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。
- -Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。
- -Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。
- -XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。
- -XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。
- -XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。
- -XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。

